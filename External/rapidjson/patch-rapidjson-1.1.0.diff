--- a/rapidjson-1.1.0/include/rapidjson/document.h	2016-08-25 09:59:05.000000000 +0200
+++ b/rapidjson-1.1.0/include/rapidjson/document.h	2025-09-25 11:37:06.694007282 +0200
@@ -22,6 +22,8 @@
 #include "internal/strfunc.h"
 #include "memorystream.h"
 #include "encodedstream.h"
+
+#include <algorithm>
 #include <new>      // placement new
 #include <limits>
 
@@ -68,9 +70,48 @@
     https://code.google.com/p/rapidjson/issues/detail?id=64
 */
 template <typename Encoding, typename Allocator> 
-struct GenericMember { 
+class GenericMember {
+public:
+    // Allow default construction as it is needed during copying.
+    GenericMember() {}
+
     GenericValue<Encoding, Allocator> name;     //!< name of member (must be a string)
     GenericValue<Encoding, Allocator> value;    //!< value of member.
+
+#if RAPIDJSON_HAS_CXX11_RVALUE_REFS
+    //! Move constructor in C++11
+    GenericMember(GenericMember&& rhs) RAPIDJSON_NOEXCEPT
+        : name(std::move(rhs.name)),
+          value(std::move(rhs.value))
+    {
+    }
+
+    //! Move assignment in C++11
+    GenericMember& operator=(GenericMember&& rhs) RAPIDJSON_NOEXCEPT {
+        return *this = static_cast<GenericMember&>(rhs);
+    }
+#endif
+
+    //! Assignment with move semantics.
+    /*! \param rhs Source of the assignment. Its name and value will become a null value after assignment.
+    */
+    GenericMember& operator=(GenericMember& rhs) RAPIDJSON_NOEXCEPT {
+        if (RAPIDJSON_LIKELY(this != &rhs)) {
+            name = rhs.name;
+            value = rhs.value;
+        }
+        return *this;
+    }
+
+    // swap() for std::sort() and other potential use in STL.
+    friend inline void swap(GenericMember& a, GenericMember& b) RAPIDJSON_NOEXCEPT {
+        a.name.Swap(b.name);
+        a.value.Swap(b.value);
+    }
+
+private:
+    //! Copy constructor is not permitted.
+    GenericMember(const GenericMember& rhs);
 };
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -316,8 +357,6 @@
 
     GenericStringRef(const GenericStringRef& rhs) : s(rhs.s), length(rhs.length) {}
 
-    GenericStringRef& operator=(const GenericStringRef& rhs) { s = rhs.s; length = rhs.length; }
-
     //! implicit conversion to plain CharType pointer
     operator const Ch *() const { return s; }
 
@@ -1934,9 +1973,11 @@
     void SetArrayRaw(GenericValue* values, SizeType count, Allocator& allocator) {
         data_.f.flags = kArrayFlag;
         if (count) {
-            GenericValue* e = static_cast<GenericValue*>(allocator.Malloc(count * sizeof(GenericValue)));
-            SetElementsPointer(e);
-            std::memcpy(e, values, count * sizeof(GenericValue));
+            auto arr = static_cast<GenericValue*>(allocator.Malloc(count * sizeof(GenericValue)));
+            for (SizeType idx = 0; idx < count; ++idx)
+                new (arr + idx) GenericValue;
+            SetElementsPointer(arr);
+            std::copy_n(values, count, arr);
         }
         else
             SetElementsPointer(0);
@@ -1947,9 +1988,11 @@
     void SetObjectRaw(Member* members, SizeType count, Allocator& allocator) {
         data_.f.flags = kObjectFlag;
         if (count) {
-            Member* m = static_cast<Member*>(allocator.Malloc(count * sizeof(Member)));
-            SetMembersPointer(m);
-            std::memcpy(m, members, count * sizeof(Member));
+            auto arr = static_cast<Member*>(allocator.Malloc(count * sizeof(Member)));
+            for (SizeType idx = 0; idx < count; ++idx)
+                new (arr + idx) Member;
+            SetMembersPointer(arr);
+            std::copy_n(members, count, arr);
         }
         else
             SetMembersPointer(0);
